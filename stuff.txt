//int index = find(Closed.begin(), Closed.end(), v);
						//vector<Node*>::iterator start = find(Closed.begin(), Closed.end(), v);	//find() + distance() returns the index value of the currentNodes parent, 
						//int index = distance(Pointers.begin(), start);															//instead of incorrectly using correntNode->parent as parent value.

void BFS(vector<int> start, int n, long int &visits, long int &max)
{
	// start is a permutation of [1 2 3 ... n]. does not return a boolean since it always succeeds
	//initialize a vector<node*> Pointers;
	vector<Node*> Pointers;
	//initialize a Queue which is also a vector of node*;
	queue<Node*> Q;

	//Step 1: pushback([start, -1]) to Pointers; // -1 signifies that start node has no parent
	pushback(start, -1, Pointers);

	//Step 2: insert([start, Pointers.size() - 1] onto Queue;
	insert(start, Pointers.size() - 1, Q, visits, max);


	while (!Q.empty())
	{
		Node* currentNode = remove(Q);

		if (InOrderS(currentNode->key)) {
			cout << "From Goal -> Start" << endl;
			printOutput(Pointers, currentNode->parent);
			return;
		}

		vector<vector<int>> possibilities = Possibilities(n, currentNode->key);

		int i = 0;
		while (i < possibilities.size())
		{
			if (Pointers[currentNode->parent]->parent == -1 || possibilities[i] != Pointers[Pointers[currentNode->parent]->parent]->key)				//AVOIDS CYCLES OF 2. by checking its parent parent, unless its start string.
			{
				pushback(possibilities[i], currentNode->parent, Pointers);						//parent value should be the index of ITS PARENT in Pointers
				insert(possibilities[i], Pointers.size() - 1, Q, visits, max);					//parent value in queue should be ITS INDEX in Pointers vector	
			}
			i++;
		}
	}
}

bool DFS(vector<int> start, int n, vector<Node*> &Parent, int depth, long int &visits, long int &max, long int &address)
{
	stack<Node*> Stk;

	stackPushback(start, 0, 0, Stk, visits, max);
	pushback(start, -1, Parent);
	while (!Stk.empty())
	{
		Node* current = Stk.top();
		Stk.pop();
		if (InOrderS(current->key)) {
			address = current->address;
			return true;
		}
		if (current->depth < depth)
		{
			vector<vector<int>> possibilities = Possibilities(n, current->key);

			int i = 0;
			while (i < possibilities.size())
			{
				if (Parent[current->address]->parent == -1 || possibilities[i] != Parent[current->address]->key  /*possibilities[i] != Parent[Parent[current->address]->parent]->key*/)
				{
					pushback(possibilities[i], current->address, Parent);
					stackPushback(possibilities[i], Parent.size() - 1, current->depth + 1, Stk, visits, max);
				}
				i++;
			}
		}
	}
	return false;
}

void IDS(vector<int> start, int n, long int &visits, long int &max)
{
	//vector<Node*>Parent;

	int depth = 0;
	long int address = 0;
	while (depth > -1)
	{
		vector<Node*>Parent;
		if (DFS(start, n, Parent, depth, visits, max, address))
		{ 
			cout << endl;
			cout << "From Goal -> Start" << endl;
			cout << "Depth: " << depth << endl;
			depth = -2;
			printOutput(Parent, address);
			return;
		}
		depth++;

	}
	//cout << "Unable to find In depth" << endl;
}
void stackPushback(vector<int> key, int address, int depth, stack<Node*> &Stk, long int &visits, long int &max)
{
	Node* temp = new Node;
	temp->key = key;
	temp->address = address;
	temp->depth = depth;
	Stk.push(temp);
	visits++;
	if (Stk.size() > max)
		max = Stk.size();
}